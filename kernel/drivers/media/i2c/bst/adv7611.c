// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * adv7611 DVI/HDMI driver for BST HDMI IN
 *
 * This file contains proprietary information that is the sole intellectual
 * property of Black Sesame Technologies, Inc. and its affiliates.
 * No portions of this material may be reproduced in any
 * form without the written permission of:
 * Black Sesame Technologies, Inc. and its affiliates
 * 2255 Martin Ave. Suite D
 * Santa Clara, CA 95050
 * Copyright @2016: all right reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 */
#include <linux/console.h>
#include <linux/delay.h>
#include <linux/errno.h>
#include <linux/fb.h>
#include <linux/fsl_devices.h>
#include <linux/i2c.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/of_device.h>
#include <video/edid.h>
#include <linux/of_gpio.h>

#include <linux/delay.h>
#include <linux/slab.h>
#include <linux/of.h>
#include <linux/of_graph.h>
#include <media/v4l2-device.h>
#include <media/v4l2-subdev.h>
#include <media/v4l2-mediabus.h>
#include <media/v4l2-ctrls.h>
#include <media/v4l2-fwnode.h>
#include <media/media-entity.h>
#include <media/media-device.h>

#include "ti_deser_hub.h"
#include "camera_common_op.h"


#ifndef EDID_LENGTH
#define EDID_LENGTH 0x80
#endif

#define Info_Frame_Map_Addr		0x6E
#define CEC_Map_Addr				0x6D
#define DPLL_Map_Addr				0x71
#define Repeater_Map_Addr			0x72
#define EDID_Map_Addr				0x73
#define HDMI_Map_Addr				0x74
#define CP_Map_Addr				0x76

#define ADDR_OFFSET(addr) (addr << 1)

struct adv7611_data {
	struct camera_dev hdmi_cam;
	int cable_plugin;
};

static uint8_t adv7611_io[13][2] = {
	{ 0xf4, ADDR_OFFSET(CEC_Map_Addr) },
	{ 0xf5, ADDR_OFFSET(Info_Frame_Map_Addr) },
	{ 0xf8, ADDR_OFFSET(DPLL_Map_Addr) },
	{ 0xf9, ADDR_OFFSET(Repeater_Map_Addr) },
	{ 0xfa, ADDR_OFFSET(EDID_Map_Addr) },
	{ 0xfb, ADDR_OFFSET(HDMI_Map_Addr) },
	{ 0xfd, ADDR_OFFSET(CP_Map_Addr) },
	{ 0x20, 0xf8 },
	{ 0x0c, 0x42 },
	{ 0x15, 0xb0 },
	{ 0x03, 0x80 },
	{ 0x06, 0xa4 },
	{ 0x0b, 0x44 },
};

static uint8_t adv7611_cp[3][2] = {
	{ 0x6c, 0x00 },
	{ 0xc9, 0x2d },
	{ 0xbf, 0x12 },
};

static uint8_t adv7611_hdmi[23][2] = {
	{ 0x9b, 0x03 }, { 0x6f, 0x08 }, { 0x85, 0x1f }, { 0x87, 0x70 },
	{ 0x57, 0xda }, { 0x58, 0x01 }, { 0x03, 0x98 }, { 0x4c, 0x44 },
	{ 0xc1, 0x01 }, { 0xc2, 0x01 }, { 0xc3, 0x01 }, { 0xc4, 0x01 },
	{ 0xc5, 0x01 }, { 0xc6, 0x01 }, { 0xc7, 0x01 }, { 0xc8, 0x01 },
	{ 0xc9, 0x01 }, { 0xca, 0x01 }, { 0xcb, 0x01 }, { 0xcc, 0x01 },
	{ 0x48, 0x40 }, { 0x01, 0x01 }, { 0x83, 0xfe },
};

static uint8_t adv7611_edid[255][2] = {
	{ 0x01, 0xff }, { 0x02, 0xff }, { 0x03, 0xff }, { 0x04, 0xff },
	{ 0x05, 0xff }, { 0x06, 0xff }, { 0x07, 0x00 }, { 0x08, 0x10 },
	{ 0x09, 0xac }, { 0x0a, 0xd7 }, { 0x0b, 0xd0 }, { 0x0c, 0x42 },
	{ 0x0d, 0x31 }, { 0x0e, 0x31 }, { 0x0f, 0x32 }, { 0x10, 0x30 },
	{ 0x11, 0x1c }, { 0x12, 0x01 }, { 0x13, 0x03 }, { 0x14, 0x80 },
	{ 0x15, 0x33 }, { 0x16, 0x1d }, { 0x17, 0x78 }, { 0x18, 0xea },
	{ 0x19, 0xeb }, { 0x1a, 0xf5 }, { 0x1b, 0xa6 }, { 0x1c, 0x56 },
	{ 0x1d, 0x51 }, { 0x1e, 0x9c }, { 0x1f, 0x26 }, { 0x20, 0x10 },
	{ 0x21, 0x50 }, { 0x22, 0x54 }, { 0x23, 0xa5 }, { 0x24, 0x4b },
	{ 0x25, 0x00 }, { 0x26, 0x71 }, { 0x27, 0x4f }, { 0x28, 0x81 },
	{ 0x29, 0x80 }, { 0x2a, 0xa9 }, { 0x2b, 0xc0 }, { 0x2c, 0xd1 },
	{ 0x2d, 0xc0 }, { 0x2e, 0x01 }, { 0x2f, 0x01 }, { 0x30, 0x01 },
	{ 0x31, 0x01 }, { 0x32, 0x01 }, { 0x33, 0x01 }, { 0x34, 0x01 },
	{ 0x35, 0x01 }, { 0x36, 0x02 }, { 0x37, 0x3a }, { 0x38, 0x80 },
	{ 0x39, 0x18 }, { 0x3a, 0x71 }, { 0x3b, 0x38 }, { 0x3c, 0x2d },
	{ 0x3d, 0x40 }, { 0x3e, 0x58 }, { 0x3f, 0x2c }, { 0x40, 0x45 },
	{ 0x41, 0x00 }, { 0x42, 0xfd }, { 0x43, 0x1e }, { 0x44, 0x11 },
	{ 0x45, 0x00 }, { 0x46, 0x00 }, { 0x47, 0x1e }, { 0x48, 0x00 },
	{ 0x49, 0x00 }, { 0x4a, 0x00 }, { 0x4b, 0xff }, { 0x4c, 0x00 },
	{ 0x4d, 0x47 }, { 0x4e, 0x30 }, { 0x4f, 0x5a }, { 0x50, 0x31 },
	{ 0x51, 0x4e }, { 0x52, 0x4d }, { 0x53, 0x32 }, { 0x54, 0x0a },
	{ 0x55, 0x20 }, { 0x56, 0x20 }, { 0x57, 0x20 }, { 0x58, 0x20 },
	{ 0x59, 0x20 }, { 0x5a, 0x00 }, { 0x5b, 0x00 }, { 0x5c, 0x00 },
	{ 0x5d, 0xfc }, { 0x5e, 0x00 }, { 0x5f, 0x44 }, { 0x60, 0x45 },
	{ 0x61, 0x4c }, { 0x62, 0x4c }, { 0x63, 0x20 }, { 0x64, 0x50 },
	{ 0x65, 0x32 }, { 0x66, 0x33 }, { 0x67, 0x31 }, { 0x68, 0x39 },
	{ 0x69, 0x48 }, { 0x6a, 0x0a }, { 0x6b, 0x20 }, { 0x6c, 0x00 },
	{ 0x6d, 0x00 }, { 0x6e, 0x00 }, { 0x6f, 0xfd }, { 0x70, 0x00 },
	{ 0x71, 0x38 }, { 0x72, 0x4c }, { 0x73, 0x1e }, { 0x74, 0x53 },
	{ 0x75, 0x11 }, { 0x76, 0x00 }, { 0x77, 0x0a }, { 0x78, 0x20 },
	{ 0x79, 0x20 }, { 0x7a, 0x20 }, { 0x7b, 0x20 }, { 0x7c, 0x20 },
	{ 0x7d, 0x20 }, { 0x7e, 0x01 }, { 0x7f, 0xe4 }, { 0x80, 0x00 },
	{ 0x81, 0x00 }, { 0x82, 0x00 }, { 0x83, 0x00 }, { 0x84, 0x00 },
	{ 0x85, 0x00 }, { 0x86, 0x00 }, { 0x87, 0x00 }, { 0x88, 0x00 },
	{ 0x89, 0x00 }, { 0x8a, 0x00 }, { 0x8b, 0x00 }, { 0x8c, 0x00 },
	{ 0x8d, 0x00 }, { 0x8e, 0x00 }, { 0x8f, 0x00 }, { 0x90, 0x00 },
	{ 0x91, 0x00 }, { 0x92, 0x00 }, { 0x93, 0x00 }, { 0x94, 0x00 },
	{ 0x95, 0x00 }, { 0x96, 0x00 }, { 0x97, 0x00 }, { 0x98, 0x00 },
	{ 0x99, 0x00 }, { 0x9a, 0x00 }, { 0x9b, 0x00 }, { 0x9c, 0x00 },
	{ 0x9d, 0x00 }, { 0x9e, 0x00 }, { 0x9f, 0x00 }, { 0xa0, 0x00 },
	{ 0xa1, 0x00 }, { 0xa2, 0x00 }, { 0xa3, 0x00 }, { 0xa4, 0x00 },
	{ 0xa5, 0x00 }, { 0xa6, 0x00 }, { 0xa7, 0x00 }, { 0xa8, 0x00 },
	{ 0xa9, 0x00 }, { 0xaa, 0x00 }, { 0xab, 0x00 }, { 0xac, 0x00 },
	{ 0xad, 0x00 }, { 0xae, 0x00 }, { 0xaf, 0x00 }, { 0xb0, 0x00 },
	{ 0xb1, 0x00 }, { 0xb2, 0x00 }, { 0xb3, 0x00 }, { 0xb4, 0x00 },
	{ 0xb5, 0x00 }, { 0xb6, 0x00 }, { 0xb7, 0x00 }, { 0xb8, 0x00 },
	{ 0xb9, 0x00 }, { 0xba, 0x00 }, { 0xbb, 0x00 }, { 0xbc, 0x00 },
	{ 0xbd, 0x00 }, { 0xbe, 0x00 }, { 0xbf, 0x00 }, { 0xc0, 0x00 },
	{ 0xc1, 0x00 }, { 0xc2, 0x00 }, { 0xc3, 0x00 }, { 0xc4, 0x00 },
	{ 0xc5, 0x00 }, { 0xc6, 0x00 }, { 0xc7, 0x00 }, { 0xc8, 0x00 },
	{ 0xc9, 0x00 }, { 0xca, 0x00 }, { 0xcb, 0x00 }, { 0xcc, 0x00 },
	{ 0xcd, 0x00 }, { 0xce, 0x00 }, { 0xcf, 0x00 }, { 0xd0, 0x00 },
	{ 0xd1, 0x00 }, { 0xd2, 0x00 }, { 0xd3, 0x00 }, { 0xd4, 0x00 },
	{ 0xd5, 0x00 }, { 0xd6, 0x00 }, { 0xd7, 0x00 }, { 0xd8, 0x00 },
	{ 0xd9, 0x00 }, { 0xda, 0x00 }, { 0xdb, 0x00 }, { 0xdc, 0x00 },
	{ 0xdd, 0x00 }, { 0xde, 0x00 }, { 0xdf, 0x00 }, { 0xe0, 0x00 },
	{ 0xe1, 0x00 }, { 0xe2, 0x00 }, { 0xe3, 0x00 }, { 0xe4, 0x00 },
	{ 0xe5, 0x00 }, { 0xe6, 0x00 }, { 0xe7, 0x00 }, { 0xe8, 0x00 },
	{ 0xe9, 0x00 }, { 0xea, 0x00 }, { 0xeb, 0x00 }, { 0xec, 0x00 },
	{ 0xed, 0x00 }, { 0xee, 0x00 }, { 0xef, 0x00 }, { 0xf0, 0x00 },
	{ 0xf1, 0x00 }, { 0xf2, 0x00 }, { 0xf3, 0x00 }, { 0xf4, 0x00 },
	{ 0xf5, 0x00 }, { 0xf6, 0x00 }, { 0xf7, 0x00 }, { 0xf8, 0x00 },
	{ 0xf9, 0x00 }, { 0xfa, 0x00 }, { 0xfb, 0x00 }, { 0xfc, 0x00 },
	{ 0xfd, 0x00 }, { 0xfe, 0x00 }, { 0xff, 0x00 },
};

static uint8_t adv7611_repeat[1][2] = {
	{ 0x74, 0x01 },
};

static void adv76xx_reset(int reset)
{
	if (1) {
		gpio_direction_output(reset, 0);
		usleep_range(5000, 10000);
		gpio_direction_output(reset, 1);
		/* It is recommended to wait 5 ms after the low pulse before */
		/* an I2C write is performed to the ADV76XX. */
		usleep_range(5000, 10000);
	}
}

static struct v4l2_subdev_ops hdmi_ops;

/* -----------------------------------------------------------------------------
 * Media Operations
 */

static const struct media_entity_operations hdmi_media_ops = {
	.link_validate = v4l2_subdev_link_validate,
};

static int adv7611_probe(struct i2c_client *client,
			 const struct i2c_device_id *id)
{
	struct i2c_adapter *adap; // = to_i2c_adapter(client->dev.parent);
	int i;
	struct adv7611_data *adv7611;
	struct camera_dev *cam;
	struct device *dev = &client->dev;
	int reset_pin = 0;
	int ret;

	adap = client->adapter;
	if (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_BYTE)) {
		dev_err(&client->dev, "i2c_check_functionality error\n");
		return -ENODEV;
	}

	adv7611 = devm_kzalloc(&client->dev, sizeof(*adv7611), GFP_KERNEL);
	if (!adv7611)
		return -ENOMEM;

	i2c_set_clientdata(client, adv7611);

	cam = &adv7611->hdmi_cam;
	cam->i2c_client = client;
	cam->dev = dev;
	ret = parse_camera_endpoint(cam, dev->of_node);
	if (ret) {
		dev_err(dev, "parse_camera_endpoint error, ret = %d\n", ret);
		return ret;
	}
	ret = init_camera_dev(cam, &hdmi_ops, &hdmi_media_ops);
	if (ret) {
		dev_err(dev, "init_camera_dev error, ret = %d\n", ret);
		return ret;
	}

	cam->isp_data.i2cRegBase = 0;
	cam->isp_data.sensorRdWrMode = BST_SENSOR_RW_MODE_BYTE_REG_BYTE_DATA;
	cam->isp_data.sensorType = BST_SENSOR_TYPE_YUV422;
	cam->isp_data.sensorDevID = 0;
	cam->isp_data.rawinfo.srcSel = BST_ISP_INPUT_HDMI; //override srcSel to HDMI

	reset_pin = of_get_named_gpio(client->dev.of_node, "reset-gpios", 0);
	if (gpio_is_valid(reset_pin)) {
		ret = devm_gpio_request(&client->dev, reset_pin,
					dev_name(&client->dev));
	}
	adv76xx_reset(reset_pin);
	if (bst_i2c_write_byte_data_byte_reg(adap, 0x4c, 0x1b, 0x01)) {
		dev_err(dev, " adv7611 SAMPLE_ALSB push failed");
		return 0;
	}
	for (i = 0; i < 13; i++) {
		if (bst_i2c_write_byte_data_byte_reg(adap, 0x4d,
						     adv7611_io[i][0],
						     adv7611_io[i][1]) < 0) {
			dev_err(dev, " adv7611 write error: %x ---> %x",
			       adv7611_io[i][0], adv7611_io[i][1]);
			return 0;
		}
	}

	for (i = 0; i < 3; i++) {
		if (bst_i2c_write_byte_data_byte_reg(adap, CP_Map_Addr,
						     adv7611_cp[i][0],
						     adv7611_cp[i][1]) < 0)
			dev_err(dev, " adv7611 write error: %x ---> %x",
				adv7611_cp[i][0], adv7611_cp[i][1]);
	}

	for (i = 0; i < 23; i++) {
		if (bst_i2c_write_byte_data_byte_reg(adap, HDMI_Map_Addr,
						     adv7611_hdmi[i][0],
						     adv7611_hdmi[i][1]) < 0)
			dev_err(dev, " adv7611 write error: %x ---> %x",
				adv7611_hdmi[i][0], adv7611_hdmi[i][1]);
	}

	for (i = 0; i < 1; i++) {
		if (bst_i2c_write_byte_data_byte_reg(adap, Repeater_Map_Addr,
						     adv7611_repeat[i][0],
						     adv7611_repeat[i][1]) < 0)
			dev_err(dev, " adv7611 write error: %x ---> %x",
				adv7611_repeat[i][0], adv7611_repeat[i][1]);
	}

	for (i = 0; i < 255; i++) {
		if (bst_i2c_write_byte_data_byte_reg(adap, EDID_Map_Addr,
						     adv7611_edid[i][0],
						     adv7611_edid[i][1]) < 0)
			dev_err(dev, " adv7611 write error: %x ---> %x",
				adv7611_edid[i][0], adv7611_edid[i][1]);
	}

	return 0;
}

static int adv7611_remove(struct i2c_client *client)
{
	return 0;
}

static const struct i2c_device_id adv7611_id[] = {
	{ "adv7611", 0 },
	{},
};
MODULE_DEVICE_TABLE(i2c, adv7611_id);

static const struct of_device_id adv7611_dt_ids[] = {
	{
		.compatible = "adi,adv7611",
	},
};
MODULE_DEVICE_TABLE(of, adv7611_dt_ids);

static struct i2c_driver adv7611_i2c_driver = {
	.driver = {
		.name = "adi,adv7611",
		.owner = THIS_MODULE,
		.of_match_table = adv7611_dt_ids,
	},
	.probe = adv7611_probe,
	.remove = adv7611_remove,
	.id_table = adv7611_id,
};
module_i2c_driver(adv7611_i2c_driver);

MODULE_AUTHOR("<wen.xiao> wen.xiao@bst.ai");
MODULE_DESCRIPTION("adv7611 DVI/HDMI driver");
MODULE_LICENSE("GPL");
